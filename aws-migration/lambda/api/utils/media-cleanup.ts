/**
 * Shared S3/CloudFront media cleanup utilities.
 *
 * Used by delete handlers (posts, peaks) and scheduled cleanup (peaks-cleanup-expired).
 * Centralises extractS3Key, variant expansion, S3 batch delete, and CloudFront invalidation.
 */

import { S3Client, DeleteObjectsCommand } from '@aws-sdk/client-s3';
import { CloudFrontClient, CreateInvalidationCommand } from '@aws-sdk/client-cloudfront';
import { createLogger } from './logger';

const log = createLogger('media-cleanup');

// ── Shared clients (singleton per Lambda cold-start) ─────────────────

const s3Client = new S3Client({
  requestChecksumCalculation: 'WHEN_REQUIRED',
  responseChecksumValidation: 'WHEN_REQUIRED',
});

const cfClient = new CloudFrontClient({});

const MEDIA_BUCKET = process.env.MEDIA_BUCKET || '';
const CLOUDFRONT_DISTRIBUTION_ID = process.env.CLOUDFRONT_DISTRIBUTION_ID || '';

/** Optimised image variant directories generated by the image pipeline. */
const VARIANT_NAMES = ['large', 'medium', 'thumb'];

// ── Helpers ──────────────────────────────────────────────────────────

/**
 * Extract S3 key from a full S3/CloudFront URL.
 * Handles: https://bucket.s3.amazonaws.com/key, https://cdn.example.com/key
 */
export function extractS3Key(url: string): string | null {
  try {
    const parsed = new URL(url);
    const key = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname;
    return key || null;
  } catch {
    return null;
  }
}

/**
 * Given a list of media URLs, build the full set of S3 object keys to delete,
 * including optimised variants (large/, medium/, thumb/ in .jpg and .webp).
 */
export function buildS3Keys(urls: string[]): { Key: string }[] {
  const s3Keys: { Key: string }[] = [];

  for (const url of urls) {
    const key = extractS3Key(url);
    if (!key) continue;

    s3Keys.push({ Key: key });

    // Also include optimised variants
    for (const variant of VARIANT_NAMES) {
      const parts = key.split('/');
      const filename = parts.at(-1)!;
      const baseName = filename.substring(0, filename.lastIndexOf('.'));
      const prefix = parts.slice(0, -1).join('/');
      s3Keys.push({ Key: `${prefix}/${variant}/${baseName}.jpg` });
      s3Keys.push({ Key: `${prefix}/${variant}/${baseName}.webp` });
    }
  }

  return s3Keys;
}

// ── Public API ───────────────────────────────────────────────────────

export interface MediaCleanupOptions {
  /** All media URLs to delete (may include nulls/undefined — they are filtered out). */
  urls: (string | null | undefined)[];
  /** Caller reference prefix for the CloudFront invalidation batch (e.g. "post-delete"). */
  callerPrefix: string;
  /** Resource ID — appended to the CloudFront caller reference for uniqueness. */
  resourceId: string;
}

/**
 * Best-effort S3 media deletion + CloudFront cache invalidation.
 * Errors are logged but never thrown — callers can fire-and-forget.
 */
export async function cleanupMedia(options: MediaCleanupOptions): Promise<void> {
  if (!MEDIA_BUCKET) return;

  const validUrls = options.urls.filter((u): u is string => typeof u === 'string' && u.length > 0);
  const s3Keys = buildS3Keys(validUrls);
  if (s3Keys.length === 0) return;

  // S3 batch delete
  try {
    await s3Client.send(new DeleteObjectsCommand({
      Bucket: MEDIA_BUCKET,
      Delete: { Objects: s3Keys, Quiet: true },
    }));
  } catch (s3Error: unknown) {
    log.error(`Failed to clean up S3 media (${options.callerPrefix})`, s3Error);
  }

  // CloudFront invalidation (best-effort)
  if (CLOUDFRONT_DISTRIBUTION_ID) {
    try {
      const paths = s3Keys.map(k => `/${k.Key}`);
      await cfClient.send(new CreateInvalidationCommand({
        DistributionId: CLOUDFRONT_DISTRIBUTION_ID,
        InvalidationBatch: {
          CallerReference: `${options.callerPrefix}-${options.resourceId}-${Date.now()}`,
          Paths: { Quantity: paths.length, Items: paths },
        },
      }));
    } catch (cfError: unknown) {
      log.error(`Failed to invalidate CloudFront cache (${options.callerPrefix})`, cfError);
    }
  }
}
