# Smuppy — Stability & Anti-Regression Plan

> **Parent**: [CLAUDE.md](../CLAUDE.md) | **Workflow**: [CLAUDE-WORKFLOW.md](../CLAUDE-WORKFLOW.md)
>
> **Status**: Binding. All agents and developers MUST follow this plan.
>
> **Goal**: Bugs become rare, reproducible, and detected before production.
>
> **Principle**: We move from "fix and hope" to "fix and prevent regression."

---

## 1. Environment Determinism (No Phantom Bugs)

If the environment is not deterministic, you are chasing ghosts.

### 1.1 Version Locking (MANDATORY)

| What | How | File |
|------|-----|------|
| **Node.js** | `.nvmrc` with exact version (e.g., `22`) | `.nvmrc` |
| **Package manager** | `packageManager` field in `package.json` | `package.json` |
| **Dependencies** | `npm ci` only (never `npm install` in CI) | `package-lock.json` |
| **Expo SDK** | Exact version in `package.json` (currently SDK 54) | `package.json` |
| **AWS SDK (Lambda)** | Exact versions, no `^` prefix | `aws-migration/lambda/*/package.json` |

### 1.2 Clean Script (Single Source of Truth)

One command to reset to clean state:

```bash
npm run clean
# Clears: node_modules, .expo, metro cache, watchman, pod cache
# Then: npm ci && npx expo-doctor
```

### 1.3 Build Reproducibility

- Local build MUST match CI build (same Node version, same `npm ci`)
- EAS builds use `eas.json` profile — never override versions ad hoc
- Lambda deploys use `cdk deploy` from `aws-migration/infrastructure/` — always

---

## 2. CI Gate — Nothing Merges If Red

The CI pipeline (`.github/workflows/ci.yml`) already runs:

| Check | Status | Action Needed |
|-------|--------|---------------|
| ESLint | Exists | Keep |
| TypeScript (`tsc --noEmit`) | Exists | Keep |
| Unit tests (Jest) | Exists but 2% threshold | **Raise thresholds progressively** |
| Build test (iOS + Android) | Exists | Keep |
| Security scan (gitleaks + npm audit) | Exists | Keep |
| Lambda TypeScript check | Exists | Keep |
| CDK synth test | Exists | Keep |
| Maestro E2E smoke | **Missing from CI** | **Add** |

### 2.1 Coverage Threshold Roadmap

| Phase | Branch % | Function % | Line % | Timeline |
|-------|----------|------------|--------|----------|
| Current | 2% | 2% | 2% | Now |
| Phase 1 | 10% | 10% | 10% | After writing critical path tests |
| Phase 2 | 30% | 30% | 30% | After stability sprint |
| Phase 3 | 50% | 50% | 50% | Before App Store V2 |

**Rule**: Coverage thresholds only go UP, never down. Ratchet pattern.

### 2.2 CI Rule

**If CI is red, no merge. No exceptions.**

---

## 3. Critical Path Test Map (5 Smoke Tests)

These 5 flows represent 80% of user value. Each MUST have:
- A Maestro E2E flow (already partially exists in `.maestro/flows/`)
- A unit test for the core logic

| # | Flow | Maestro File | Unit Test Scope |
|---|------|-------------|-----------------|
| 1 | **Auth**: Login + token refresh + arrive Home | `02-auth-login.yaml` | `authService.login()`, token storage |
| 2 | **Feed**: Load VibesFeed + scroll + pull-to-refresh | `03-feed-navigation.yaml` | `feedStore`, API pagination |
| 3 | **Post**: Create post + upload + visible in feed | `05-post-interaction.yaml` | `awsAPI.createPost()`, optimistic update |
| 4 | **Peaks**: View story circles + open viewer + navigate | `06-peaks-feed.yaml` | Group logic, navigation state |
| 5 | **Profile**: View own profile + edit + save | `04-profile-screen.yaml` | `userStore`, profile API |

### 3.1 Test Writing Priority

1. **Crash / blockers** first
2. **Data inconsistency** (state, cache, optimistic updates)
3. **Navigation** (stack, deep links, back button)
4. **Race conditions** (async, double tap, concurrent requests)
5. **Backend contract** (API shape changes, validation)

---

## 4. Bug Discipline (MANDATORY — Every Bug Becomes a Test)

### 4.1 Bug Fix Process

```
1. Bug reported (or discovered)
   │
2. Write "Steps to Reproduce" + "Expected vs Actual"
   │
3. Write a test that REPRODUCES the bug (test fails = bug confirmed)
   │
4. Fix the bug (test now passes)
   │
5. Commit fix + test together
   │
6. CI passes → merge
```

### 4.2 Rules

- **NEVER** fix a bug without a test that prevents its return
- If the bug is in a Lambda handler: write a unit test for that handler
- If the bug is in frontend state: write a store/hook test
- If the bug is a navigation issue: write a Maestro flow
- If writing a full test is impractical: add a TypeScript type guard or runtime assertion at minimum

### 4.3 Bug Test Naming Convention

```
describe('peaks/list handler', () => {
  it('BUG-2026-02-10: excludes hidden peaks from feed mode', () => {
    // Regression test for: hidden peaks appearing in feed
    // ...
  });
});
```

Date-stamped bug references make regressions traceable.

---

## 5. AI Change Discipline (Minimal Diffs Only)

The #1 cause of regressions is large, multi-purpose diffs generated by AI.

### 5.1 Rules for AI-Generated Changes

| Rule | Detail |
|------|--------|
| **1 PR = 1 purpose** | One bug fix or one feature. Never both. |
| **Max scope** | Ideally < 10 files modified per commit |
| **No cleanup in fix PRs** | Refactors, formatting, dead code removal go in separate commits |
| **No implicit changes** | If AI modifies code outside the bug's scope, reject it |
| **Minimal fix** | The smallest change that fixes the bug. Not the "best" refactor. |
| **Read before write** | AI MUST read all affected files before making changes |
| **Verify after write** | `npx tsc --noEmit` + `npx eslint` + mental walkthrough |

### 5.2 Review Checklist for AI-Generated Code

Before accepting any AI-generated change:

- [ ] Does the diff ONLY touch files related to the stated purpose?
- [ ] Are there any "bonus" refactors or cleanups mixed in?
- [ ] Does the change introduce new dependencies?
- [ ] Is the change reversible (can be reverted without breaking other things)?
- [ ] Does `npx tsc --noEmit` pass with zero new errors?

---

## 6. Observability (Know WHERE It Breaks)

### 6.1 Required Instrumentation

| Layer | Tool | Status |
|-------|------|--------|
| **Mobile crashes** | Sentry (`initSentry()` in App.js) | Implemented |
| **JS errors** | Sentry React Native SDK (`captureException`, `captureMessage`) | Implemented |
| **API errors** | CloudWatch Logs (already via `createLogger`) | Exists |
| **Network failures** | Client-side error boundary + retry logic | Partial |
| **Navigation** | Screen tracking analytics | **TODO** |

### 6.2 Structured Error Logging

Every error log MUST include:
- **Where**: file + function name
- **What**: error message (sanitized, no PII)
- **Context**: request ID, user action that triggered it
- **Severity**: crash / error / warning

Lambda handlers already use `createLogger()`. Frontend needs equivalent structured logging.

### 6.3 When Something Breaks in Production

```
1. Check Sentry/Crashlytics for stack trace
   │
2. Reproduce locally with same data/state
   │
3. Write a failing test
   │
4. Fix + test + deploy
   │
5. Verify fix is live (Lambda invoke or EAS update)
```

---

## 7. Stability Sprint Protocol

When entering a stability period (feature freeze):

### 7.1 Triage

Collect all known bugs and classify:

| Category | Priority | Example |
|----------|----------|---------|
| **Crash** | P0 — fix now | App crashes on peak view with null video |
| **Data loss** | P0 — fix now | Comment posted but lost on refresh |
| **Broken flow** | P1 — fix this sprint | Can't navigate back from settings |
| **Visual glitch** | P2 — fix if time | Avatar flickers on profile load |
| **Edge case** | P3 — backlog | Search returns duplicates on fast scroll |

### 7.2 Fix Order

1. All P0s first (with regression tests)
2. P1s (with regression tests)
3. Raise coverage thresholds
4. Add missing Maestro smoke tests to CI
5. P2s if time permits

### 7.3 Exit Criteria

Stability sprint is DONE when:
- [ ] Zero P0 bugs open
- [ ] Zero P1 bugs open
- [ ] All 5 critical path Maestro flows pass
- [ ] Jest coverage above Phase 1 thresholds (10%)
- [ ] CI pipeline fully green on main
- [ ] Sentry/Crashlytics installed and reporting

---

## 8. Implementation Checklist (Do Today)

### Immediate (Day 1)

- [x] Create `.nvmrc` with `22` (match CI)
- [x] Add `"packageManager": "npm@10.9.2"` to `package.json`
- [x] Install Sentry: `npx expo install @sentry/react-native`
- [x] Initialize Sentry in `App.tsx` with DSN from environment

### This Week

- [ ] Raise Jest coverage thresholds to 10%
- [ ] Write unit tests for 5 critical services:
  - `authService` (login, refresh, logout)
  - `awsAPI.getPeaks` / `awsAPI.createPost`
  - `feedStore` (pagination, optimistic updates)
  - `userStore` (profile load, update)
  - `usePreventDoubleNavigation` hook
- [x] Add `npm run clean` script to `package.json`
- [ ] Run existing Maestro flows, fix any that fail

### This Month

- [ ] Add Maestro E2E to CI pipeline (run on every PR)
- [ ] Write regression tests for every bug fixed in the past 30 days
- [ ] Raise coverage thresholds to 30%
- [ ] Set up Sentry alerts for new crash types

---

## 9. File Inventory

| File | Purpose |
|------|---------|
| `docs/STABILITY.md` | This document — stability strategy |
| `CLAUDE.md` | Project rules — references this plan |
| `CLAUDE-WORKFLOW.md` | Dev workflow — includes stability verification |
| `.github/workflows/ci.yml` | CI pipeline |
| `jest.config.js` | Jest configuration + coverage thresholds |
| `.maestro/` | Maestro E2E test flows |
| `e2e/` | E2E test code (Detox-based) |
| `src/__tests__/` | Unit tests |
| `.nvmrc` | Node version lock |
