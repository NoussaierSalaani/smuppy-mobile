{
  "version": 3,
  "sources": ["../../../lambda/api/posts/list.ts"],
  "sourcesContent": ["/**\n * Posts List Lambda - Instagram-Level Scale\n * Handles millions of requests with caching, cursor pagination, and feed algorithms\n */\n\nimport { APIGatewayProxyHandler, APIGatewayProxyResult } from 'aws-lambda';\nimport { Pool, PoolConfig } from 'pg';\nimport Redis from 'ioredis';\nimport { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';\n\n// Connection pools (reused across Lambda invocations for performance)\nlet pgPool: Pool | null = null;\nlet redis: Redis | null = null;\nlet dbCredentials: any = null;\n\nconst secretsManager = new SecretsManagerClient({});\n\nconst {\n  DB_SECRET_ARN,\n  REDIS_HOST,\n  REDIS_PORT = '6379',\n  ENVIRONMENT = 'staging',\n} = process.env;\n\nconst CACHE_TTL = {\n  POSTS_LIST: 60,\n  POST_DETAIL: 300,\n  USER_FEED: 30,\n};\n\nasync function getDbCredentials(): Promise<any> {\n  if (dbCredentials) return dbCredentials;\n  const command = new GetSecretValueCommand({ SecretId: DB_SECRET_ARN });\n  const response = await secretsManager.send(command);\n  dbCredentials = JSON.parse(response.SecretString || '{}');\n  return dbCredentials;\n}\n\nasync function getPgPool(): Promise<Pool> {\n  if (pgPool) return pgPool;\n  const creds = await getDbCredentials();\n  const config: PoolConfig = {\n    host: creds.host,\n    port: creds.port || 5432,\n    database: creds.dbname || 'smuppy',\n    user: creds.username,\n    password: creds.password,\n    ssl: { rejectUnauthorized: false },\n    max: 10,\n    idleTimeoutMillis: 30000,\n    connectionTimeoutMillis: 5000,\n  };\n  pgPool = new Pool(config);\n  return pgPool;\n}\n\nfunction getRedis(): Redis {\n  if (redis) return redis;\n  redis = new Redis({\n    host: REDIS_HOST,\n    port: parseInt(REDIS_PORT),\n    tls: {},\n    maxRetriesPerRequest: 3,\n    lazyConnect: true,\n  });\n  return redis;\n}\n\nfunction response(statusCode: number, body: any): APIGatewayProxyResult {\n  return {\n    statusCode,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Credentials': 'true',\n      'Cache-Control': statusCode === 200 ? 'public, max-age=60' : 'no-cache',\n    },\n    body: JSON.stringify(body),\n  };\n}\n\nexport const handler: APIGatewayProxyHandler = async (event) => {\n  const startTime = Date.now();\n\n  try {\n    const {\n      limit = '20',\n      cursor,\n      type = 'all',\n      userId,\n    } = event.queryStringParameters || {};\n\n    const parsedLimit = Math.min(parseInt(limit), 100);\n    const requesterId = event.requestContext.authorizer?.claims?.sub;\n    const cacheKey = `posts:list:${type}:${userId || 'all'}:${cursor || 'first'}:${parsedLimit}`;\n\n    // Try cache first (for public feeds)\n    const redisClient = getRedis();\n    if (type !== 'following') {\n      try {\n        const cached = await redisClient.get(cacheKey);\n        if (cached) {\n          return response(200, { ...JSON.parse(cached), cached: true, latency: Date.now() - startTime });\n        }\n      } catch (e) { /* Cache miss, continue */ }\n    }\n\n    const pool = await getPgPool();\n    let query: string;\n    let params: any[];\n\n    if (type === 'following' && requesterId) {\n      query = `\n        SELECT p.id, p.user_id as \"authorId\", p.content, p.media_urls as \"mediaUrls\", p.media_type as \"mediaType\",\n               p.likes_count as \"likesCount\", p.comments_count as \"commentsCount\", p.created_at as \"createdAt\",\n               u.username, u.full_name as \"fullName\", u.avatar_url as \"avatarUrl\", u.is_verified as \"isVerified\", u.account_type as \"accountType\",\n               EXISTS(SELECT 1 FROM likes l WHERE l.post_id = p.id AND l.user_id = $1) as \"isLiked\"\n        FROM posts p\n        JOIN users u ON p.user_id = u.id\n        JOIN follows f ON f.following_id = p.user_id AND f.follower_id = $1 AND f.status = 'accepted'\n        WHERE p.deleted_at IS NULL ${cursor ? 'AND p.created_at < $3' : ''}\n        ORDER BY p.created_at DESC LIMIT $2\n      `;\n      params = cursor ? [requesterId, parsedLimit + 1, new Date(parseInt(cursor))] : [requesterId, parsedLimit + 1];\n    } else if (userId) {\n      query = `\n        SELECT p.id, p.user_id as \"authorId\", p.content, p.media_urls as \"mediaUrls\", p.media_type as \"mediaType\",\n               p.likes_count as \"likesCount\", p.comments_count as \"commentsCount\", p.created_at as \"createdAt\",\n               u.username, u.full_name as \"fullName\", u.avatar_url as \"avatarUrl\", u.is_verified as \"isVerified\", u.account_type as \"accountType\"\n        FROM posts p JOIN users u ON p.user_id = u.id\n        WHERE p.user_id = $1 AND p.deleted_at IS NULL ${cursor ? 'AND p.created_at < $3' : ''}\n        ORDER BY p.created_at DESC LIMIT $2\n      `;\n      params = cursor ? [userId, parsedLimit + 1, new Date(parseInt(cursor))] : [userId, parsedLimit + 1];\n    } else {\n      query = `\n        SELECT p.id, p.user_id as \"authorId\", p.content, p.media_urls as \"mediaUrls\", p.media_type as \"mediaType\",\n               p.likes_count as \"likesCount\", p.comments_count as \"commentsCount\", p.created_at as \"createdAt\",\n               u.username, u.full_name as \"fullName\", u.avatar_url as \"avatarUrl\", u.is_verified as \"isVerified\", u.account_type as \"accountType\"\n        FROM posts p JOIN users u ON p.user_id = u.id\n        WHERE p.deleted_at IS NULL ${cursor ? 'AND p.created_at < $2' : ''}\n        ORDER BY CASE WHEN p.created_at > NOW() - INTERVAL '24 hours' THEN p.likes_count * 2 + p.comments_count ELSE p.likes_count + p.comments_count END DESC, p.created_at DESC\n        LIMIT $1\n      `;\n      params = cursor ? [parsedLimit + 1, new Date(parseInt(cursor))] : [parsedLimit + 1];\n    }\n\n    const result = await pool.query(query, params);\n    const hasMore = result.rows.length > parsedLimit;\n    const posts = hasMore ? result.rows.slice(0, parsedLimit) : result.rows;\n\n    const formattedPosts = posts.map(post => ({\n      id: post.id, authorId: post.authorId, content: post.content, mediaUrls: post.mediaUrls || [],\n      mediaType: post.mediaType, likesCount: parseInt(post.likesCount) || 0, commentsCount: parseInt(post.commentsCount) || 0,\n      createdAt: post.createdAt, isLiked: post.isLiked || false,\n      author: { id: post.authorId, username: post.username, fullName: post.fullName, avatarUrl: post.avatarUrl, isVerified: post.isVerified, accountType: post.accountType },\n    }));\n\n    const responseData = { posts: formattedPosts, nextCursor: hasMore ? posts[posts.length - 1].createdAt.getTime().toString() : null, hasMore, total: formattedPosts.length };\n\n    if (type !== 'following') {\n      try { await redisClient.setex(cacheKey, CACHE_TTL.POSTS_LIST, JSON.stringify(responseData)); } catch (e) { /* Ignore */ }\n    }\n\n    return response(200, { ...responseData, cached: false, latency: Date.now() - startTime });\n  } catch (error: any) {\n    console.error('Error fetching posts:', error);\n    return response(500, { error: 'Internal server error', message: ENVIRONMENT === 'staging' ? error.message : undefined });\n  }\n};\n"],
  "mappings": "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",
  "names": ["list_exports", "__export", "handler", "__toCommonJS", "import_pg", "import_ioredis", "import_client_secrets_manager", "pgPool", "redis", "dbCredentials", "secretsManager", "DB_SECRET_ARN", "REDIS_HOST", "REDIS_PORT", "ENVIRONMENT", "CACHE_TTL", "getDbCredentials", "command", "response", "getPgPool", "creds", "config", "getRedis", "Redis", "statusCode", "body", "event", "startTime", "limit", "cursor", "type", "userId", "parsedLimit", "requesterId", "cacheKey", "redisClient", "cached", "pool", "query", "params", "result", "hasMore", "posts", "formattedPosts", "post", "responseData", "error"]
}
